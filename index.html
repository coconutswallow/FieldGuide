---
layout: default
title: Hawthorne Field Guide
---

<h2>Credits</h2>
<p>The original Hawthorne Field Guide was been created by <b>km.d, MonoxideAtWork</b> and <b>Rexen</b> with the assistance of <b>Kathy</b> for updating and
formatting using the Homebrewery in collaboration with the Lore Consultants and Rules Architects of the Hawthorne Dungeons & Dragons Guild</p>
<p>This Digital Field Guide was created by the Hawthorne Engineers using the contents from the PDF Field Guide</p>

<h2>Monsters</h2>
<p>The monsters in this compendium have been created by various members of the community of the Hawthorne Dungeons & Dragons Guild.<br> 
  The credits are listed on the page of the statblock(s).</p>

<!-- Filter Controls -->
<div class="filter-container">
  <div class="filter-group">
    <label for="type-filter">Type:</label>
    <select id="type-filter" class="filter-select">
      <option value="">All Types</option>
    </select>
  </div>
  
  <div class="filter-group">
    <label for="cr-from">CR From:</label>
    <input type="number" id="cr-from" class="filter-input" placeholder="Min" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="cr-to">CR To:</label>
    <input type="number" id="cr-to" class="filter-input" placeholder="Max" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="size-filter">Size:</label>
    <select id="size-filter" class="filter-select">
      <option value="">All Sizes</option>
    </select>
  </div>
  
  <button id="reset-filters" class="reset-button">Reset Filters</button>
</div>

<div id="monster-count" class="monster-count"></div>

{% assign monsters_by_category = site.monsters | where_exp:"item", "item.category != null" | group_by: 'category' | sort: 'name' %}

{% for category in monsters_by_category %}
  <div class="category-section" data-category="{{ category.name }}">
    <h2 class="category-title">{{ category.name }}</h2>

    <div class="monster-list">
      {% assign sorted = category.items | sort: 'cr' %}
      {% for monster in sorted %}
        <div class="monster-card" 
             data-cr="{{ monster.cr }}" 
             data-type="{{ monster.type }}" 
             data-size="{{ monster.size }}">
          <h3><a href="{{ monster.url | relative_url }}">{{ monster.title }}</a></h3>
          <p class="monster-cr">CR {{ monster.cr }}</p>
          <p class="monster-type">{{ monster.type }}</p>
        </div>
      {% endfor %}
    </div>
  </div>
{% endfor %}

<style>
.filter-container {
  background: #FDF1DC;
  border: 2px solid #58180D;
  border-radius: 8px;
  padding: 1.5em;
  margin: 2em 0;
  display: flex;
  flex-wrap: wrap;
  gap: 1em;
  align-items: flex-end;
}

.filter-group {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  flex: 1;
  min-width: 150px;
}

.filter-group label {
  font-family: var(--font-header);
  font-weight: 700;
  color: #58180D;
  text-transform: uppercase;
  font-size: 0.9em;
  letter-spacing: 0.5px;
}

.filter-select {
  padding: 0.5em;
  border: 2px solid #58180D;
  border-radius: 4px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: #58180D;
  cursor: pointer;
}

.filter-select:focus {
  outline: none;
  border-color: #822000;
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}

.filter-input {
  padding: 0.5em;
  border: 2px solid #58180D;
  border-radius: 4px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: #58180D;
  width: 100%;
}

.filter-input:focus {
  outline: none;
  border-color: #822000;
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}

.filter-input::placeholder {
  color: #999;
  font-style: italic;
}

.reset-button {
  padding: 0.5em 1.5em;
  background: #58180D;
  color: #FDF1DC;
  border: none;
  border-radius: 4px;
  font-family: var(--font-header);
  font-size: 0.9em;
  text-transform: uppercase;
  cursor: pointer;
  transition: background 0.2s;
  height: fit-content;
}

.reset-button:hover {
  background: #822000;
}

.monster-count {
  font-family: var(--font-body);
  font-style: italic;
  color: #58180D;
  margin: 1em 0;
  font-size: 0.95em;
}

.category-section {
  margin-bottom: 2em;
}

.category-section.hidden {
  display: none;
}

.monster-card.hidden {
  display: none;
}

@media (max-width: 768px) {
  .filter-container {
    flex-direction: column;
    align-items: stretch;
  }
  
  .filter-group {
    min-width: 100%;
  }
  
  .reset-button {
    width: 100%;
  }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const typeFilter = document.getElementById('type-filter');
  const crFromInput = document.getElementById('cr-from');
  const crToInput = document.getElementById('cr-to');
  const sizeFilter = document.getElementById('size-filter');
  const resetButton = document.getElementById('reset-filters');
  const monsterCards = document.querySelectorAll('.monster-card');
  const categorySections = document.querySelectorAll('.category-section');
  const monsterCount = document.getElementById('monster-count');
  
  // Function to parse CR values (handles fractions like "1/4")
  function parseCR(crString) {
    if (!crString) return 0;
    
    // Check if it's a fraction
    if (crString.includes('/')) {
      const parts = crString.split('/');
      return parseFloat(parts[0]) / parseFloat(parts[1]);
    }
    
    return parseFloat(crString);
  }
  
  // Sort monsters by CR within each category
  categorySections.forEach(section => {
    const monsterList = section.querySelector('.monster-list');
    const cards = Array.from(monsterList.querySelectorAll('.monster-card'));
    
    // Sort cards by CR numerically
    cards.sort((a, b) => {
      const crA = parseCR(a.dataset.cr);
      const crB = parseCR(b.dataset.cr);
      return crA - crB;
    });
    
    // Re-append cards in sorted order
    cards.forEach(card => monsterList.appendChild(card));
  });
  
  // Collect unique values for filters
  const types = new Set();
  const sizes = new Set();
  
  monsterCards.forEach(card => {
    const type = card.dataset.type;
    const size = card.dataset.size;
    
    if (type) types.add(type);
    if (size) sizes.add(size);
  });
  
  // Populate filter dropdowns
  Array.from(types).sort().forEach(type => {
    const option = document.createElement('option');
    option.value = type;
    option.textContent = type;
    typeFilter.appendChild(option);
  });
  
  // Sort sizes by D&D standard order
  const sizeOrder = ['Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan'];
  Array.from(sizes).sort((a, b) => {
    return sizeOrder.indexOf(a) - sizeOrder.indexOf(b);
  }).forEach(size => {
    const option = document.createElement('option');
    option.value = size;
    option.textContent = size;
    sizeFilter.appendChild(option);
  });
  
  // Filter function
  function filterMonsters() {
    const selectedType = typeFilter.value;
    const crFrom = crFromInput.value ? parseFloat(crFromInput.value) : null;
    const crTo = crToInput.value ? parseFloat(crToInput.value) : null;
    const selectedSize = sizeFilter.value;
    
    let visibleCount = 0;
    
    monsterCards.forEach(card => {
      const cardType = card.dataset.type;
      const cardCR = parseCR(card.dataset.cr);
      const cardSize = card.dataset.size;
      
      const typeMatch = !selectedType || cardType === selectedType;
      const sizeMatch = !selectedSize || cardSize === selectedSize;
      
      // CR range matching
      let crMatch = true;
      if (crFrom !== null && cardCR < crFrom) {
        crMatch = false;
      }
      if (crTo !== null && cardCR > crTo) {
        crMatch = false;
      }
      
      if (typeMatch && crMatch && sizeMatch) {
        card.classList.remove('hidden');
        visibleCount++;
      } else {
        card.classList.add('hidden');
      }
    });
    
    // Re-sort visible monsters by CR within each category
    categorySections.forEach(section => {
      const monsterList = section.querySelector('.monster-list');
      const cards = Array.from(monsterList.querySelectorAll('.monster-card:not(.hidden)'));
      
      // Sort visible cards by CR numerically
      cards.sort((a, b) => {
        const crA = parseCR(a.dataset.cr);
        const crB = parseCR(b.dataset.cr);
        return crA - crB;
      });
      
      // Re-append visible cards in sorted order (hidden cards stay where they are)
      cards.forEach(card => monsterList.appendChild(card));
    });
    
    // Hide/show category sections based on visible monsters
    categorySections.forEach(section => {
      const visibleCardsInSection = section.querySelectorAll('.monster-card:not(.hidden)');
      if (visibleCardsInSection.length === 0) {
        section.classList.add('hidden');
      } else {
        section.classList.remove('hidden');
      }
    });
    
    // Update count
    const totalCount = monsterCards.length;
    monsterCount.textContent = `Showing ${visibleCount} of ${totalCount} monsters`;
  }
  
  // Reset function
  function resetFilters() {
    typeFilter.value = '';
    crFromInput.value = '';
    crToInput.value = '';
    sizeFilter.value = '';
    filterMonsters();
  }
  
  // Add event listeners
  typeFilter.addEventListener('change', filterMonsters);
  crFromInput.addEventListener('input', filterMonsters);
  crToInput.addEventListener('input', filterMonsters);
  sizeFilter.addEventListener('change', filterMonsters);
  resetButton.addEventListener('click', resetFilters);
  
  // Initial count
  filterMonsters();
});
</script>